/* Generated By:JavaCC: Do not edit this line. JavaccJsonParser.java */
package org.directwebremoting.json.parse.javacc;

import java.io.Reader;
import java.io.StringReader;

import org.directwebremoting.json.parse.JsonDecoder;
import org.directwebremoting.json.parse.JsonParseException;
import org.directwebremoting.json.parse.JsonParser;

/**
 * Produced by JavaCC from JavaccJsonParser.jj
 * @author Joe Walker [joe at getahead dot org]
 */
@SuppressWarnings("all")
public class JavaccJsonParser implements JsonParser, JavaccJsonParserConstants
{
    /**
     * This constructor does not create a ready-to-roll parser. One of the
     * {@link #ReInit} methods should be called first.
     */
    public JavaccJsonParser()
    {
        this(new StringReader(""));
    }

    /* (non-Javadoc)
     * @see org.directwebremoting.json.parse.JsonParser#parse(java.io.Reader, org.directwebremoting.json.parse.JsonDecoder)
     */
    public Object parse(Reader reader, JsonDecoder decoder) throws JsonParseException
    {
        ReInit(reader);
        try
        {
            top(decoder);
        }
        catch (TokenMgrError ex)
        {
            throw new JsonParseException(ex.getMessage());
        }
        return decoder.getRoot();
    }

    final public void top(JsonDecoder decoder) throws ParseException, JsonParseException
    {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case 12:
            object(decoder, null);
            break;
        case 16:
            array(decoder, null);
            break;
        default:
            jj_la1[0] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
    }

    final public void object(JsonDecoder decoder, String propertyName) throws ParseException, JsonParseException
    {
        decoder.beginObject(propertyName);
        jj_consume_token(12);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case QUOTE:
            pair(decoder);
            label_1: while (true)
            {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
                {
                case 13:
                    ;
                    break;
                default:
                    jj_la1[1] = jj_gen;
                    break label_1;
                }
                jj_consume_token(13);
                pair(decoder);
            }
            break;
        default:
            jj_la1[2] = jj_gen;
            ;
        }
        jj_consume_token(14);
        decoder.endObject(propertyName);
    }

    final public void pair(JsonDecoder decoder) throws ParseException, JsonParseException
    {
        String propertyName;
        propertyName = propertyName();
        jj_consume_token(15);
        value(decoder, propertyName);
    }

    final public void array(JsonDecoder decoder, String propertyName) throws ParseException, JsonParseException
    {
        decoder.beginArray(propertyName);
        jj_consume_token(16);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case DIGITS:
        case QUOTE:
        case 12:
        case 16:
        case 18:
        case 19:
        case 20:
        case 21:
            value(decoder, null);
            label_2: while (true)
            {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
                {
                case 13:
                    ;
                    break;
                default:
                    jj_la1[3] = jj_gen;
                    break label_2;
                }
                jj_consume_token(13);
                value(decoder, null);
            }
            break;
        default:
            jj_la1[4] = jj_gen;
            ;
        }
        jj_consume_token(17);
        decoder.endArray(propertyName);
    }

    final public void value(JsonDecoder decoder, String propertyName) throws ParseException, JsonParseException
    {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case QUOTE:
            string(decoder, propertyName);
            break;
        case DIGITS:
        case 21:
            number(decoder, propertyName);
            break;
        case 12:
            object(decoder, propertyName);
            break;
        case 16:
            array(decoder, propertyName);
            break;
        case 18:
        case 19:
        case 20:
            literal(decoder, propertyName);
            break;
        default:
            jj_la1[5] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
    }

    final public void literal(JsonDecoder decoder, String propertyName) throws ParseException, JsonParseException
    {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case 18:
            jj_consume_token(18);
            decoder.addBoolean(propertyName, true);
            break;
        case 19:
            jj_consume_token(19);
            decoder.addBoolean(propertyName, false);
            break;
        case 20:
            jj_consume_token(20);
            decoder.addNull(propertyName);
            break;
        default:
            jj_la1[6] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
    }

    final public void number(JsonDecoder decoder, String propertyName) throws ParseException, JsonParseException
    {
        String intPart = null;
        String floatPart = null;
        String expPart = null;
        intPart = getIntPart();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case 22:
            floatPart = getFloatPart();
            break;
        default:
            jj_la1[7] = jj_gen;
            ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case E:
            expPart = getExpPart();
            break;
        default:
            jj_la1[8] = jj_gen;
            ;
        }
        decoder.addNumber(propertyName, intPart, floatPart, expPart);

        // This is can help to reduce memory consumption
        intPart = null;
        floatPart = null;
        expPart = null;
    }

    final public String getIntPart() throws ParseException, JsonParseException
    {
        String digits;
        boolean negative = false;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case 21:
            jj_consume_token(21);
            negative = true;
            break;
        default:
            jj_la1[9] = jj_gen;
            ;
        }
        digits = getDigits();
        if (negative)
        {
            {
                if (true)
                {
                    return "-" + digits;
                }
            }
        }
        {
            if (true)
            {
                return digits;
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public String getFloatPart() throws ParseException, JsonParseException
    {
        String digits;
        jj_consume_token(22);
        digits = getDigits();
        {
            if (true)
            {
                return "." + digits;
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public String getExpPart() throws ParseException, JsonParseException
    {
        Token t;
        String digits;
        t = jj_consume_token(E);
        digits = getDigits();
        {
            if (true)
            {
                return t.image + digits;
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public String getDigits() throws ParseException, JsonParseException
    {
        Token t;
        t = jj_consume_token(DIGITS);
        {
            if (true)
            {
                return t.image;
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public String propertyName() throws ParseException, JsonParseException
    {
        StringBuilder builder = new StringBuilder();
        jj_consume_token(QUOTE);
        label_3: while (true)
        {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
            {
            case CHAR:
            case CNTRL_ESC:
            case HEX_ESC:
                ;
                break;
            default:
                jj_la1[10] = jj_gen;
                break label_3;
            }
            getChar(builder);
        }
        jj_consume_token(ENDQUOTE);
        {
            if (true)
            {
                return builder.toString();
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public void string(JsonDecoder decoder, String propertyName) throws ParseException, JsonParseException
    {
        StringBuilder builder = new StringBuilder();
        jj_consume_token(QUOTE);
        label_4: while (true)
        {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
            {
            case CHAR:
            case CNTRL_ESC:
            case HEX_ESC:
                ;
                break;
            default:
                jj_la1[11] = jj_gen;
                break label_4;
            }
            getChar(builder);
        }
        jj_consume_token(ENDQUOTE);
        decoder.addString(propertyName, builder.toString());
    }

    final public void getChar(StringBuilder builder) throws ParseException
    {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case CHAR:
            t = jj_consume_token(CHAR);
            break;
        case CNTRL_ESC:
            t = jj_consume_token(CNTRL_ESC);
            break;
        case HEX_ESC:
            t = jj_consume_token(HEX_ESC);
            break;
        default:
            jj_la1[12] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        if (t.image.length() < 2)
        {
            builder.append(t.image.charAt(0));
        }
        else if (t.image.length() < 6)
        {
            char c = t.image.charAt(1);
            switch (c)
            {
            case 'b':
                builder.append((char) 8);
                break;
            case 'f':
                builder.append((char) 12);
                break;
            case 'n':
                builder.append((char) 10);
                break;
            case 'r':
                builder.append((char) 13);
                break;
            case 't':
                builder.append((char) 9);
                break;
            default:
                builder.append(c);
            }
        }
        else
        {
            // hex escape code
            int i = Integer.valueOf(t.image.substring(2, 6), 16).intValue();
            builder.append((char) i);
        }
    }

    public JavaccJsonParserTokenManager token_source;

    SimpleCharStream jj_input_stream;

    public Token token, jj_nt;

    private int jj_ntk;

    private int jj_gen;

    final private int[] jj_la1 = new int[13];

    static private int[] jj_la1_0;
    static
    {
        jj_la1_0();
    }

    private static void jj_la1_0()
    {
        jj_la1_0 = new int[] { 0x11000, 0x2000, 0x10, 0x2000, 0x3d1018, 0x3d1018, 0x1c0000, 0x400000, 0x4, 0x200000, 0x980, 0x980, 0x980, };
    }

    public JavaccJsonParser(java.io.InputStream stream)
    {
        this(stream, null);
    }

    public JavaccJsonParser(java.io.InputStream stream, String encoding)
    {
        try
        {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        }
        catch (java.io.UnsupportedEncodingException e)
        {
            throw new RuntimeException(e);
        }
        token_source = new JavaccJsonParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++)
        {
            jj_la1[i] = -1;
        }
    }

    public void ReInit(java.io.InputStream stream)
    {
        ReInit(stream, null);
    }

    public void ReInit(java.io.InputStream stream, String encoding)
    {
        try
        {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        }
        catch (java.io.UnsupportedEncodingException e)
        {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++)
        {
            jj_la1[i] = -1;
        }
    }

    public JavaccJsonParser(java.io.Reader stream)
    {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new JavaccJsonParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++)
        {
            jj_la1[i] = -1;
        }
    }

    public void ReInit(java.io.Reader stream)
    {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++)
        {
            jj_la1[i] = -1;
        }
    }

    public JavaccJsonParser(JavaccJsonParserTokenManager tm)
    {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++)
        {
            jj_la1[i] = -1;
        }
    }

    public void ReInit(JavaccJsonParserTokenManager tm)
    {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++)
        {
            jj_la1[i] = -1;
        }
    }

    final private Token jj_consume_token(int kind) throws ParseException
    {
        Token oldToken;
        if ((oldToken = token).next != null)
        {
            token = token.next;
        }
        else
        {
            token = token.next = token_source.getNextToken();
        }
        jj_ntk = -1;
        if (token.kind == kind)
        {
            jj_gen++;
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    final public Token getNextToken()
    {
        if (token.next != null)
        {
            token = token.next;
        }
        else
        {
            token = token.next = token_source.getNextToken();
        }
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    final public Token getToken(int index)
    {
        Token t = token;
        for (int i = 0; i < index; i++)
        {
            if (t.next != null)
            {
                t = t.next;
            }
            else
            {
                t = t.next = token_source.getNextToken();
            }
        }
        return t;
    }

    final private int jj_ntk()
    {
        if ((jj_nt = token.next) == null)
        {
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        }
        else
        {
            return (jj_ntk = jj_nt.kind);
        }
    }

    private final java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();

    private int[] jj_expentry;

    private int jj_kind = -1;

    public ParseException generateParseException()
    {
        jj_expentries.removeAllElements();
        boolean[] la1tokens = new boolean[23];
        for (int i = 0; i < 23; i++)
        {
            la1tokens[i] = false;
        }
        if (jj_kind >= 0)
        {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 13; i++)
        {
            if (jj_la1[i] == jj_gen)
            {
                for (int j = 0; j < 32; j++)
                {
                    if ((jj_la1_0[i] & (1 << j)) != 0)
                    {
                        la1tokens[j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 23; i++)
        {
            if (la1tokens[i])
            {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++)
        {
            exptokseq[i] = (int[]) jj_expentries.elementAt(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    final public void enable_tracing()
    {
    }

    final public void disable_tracing()
    {
    }

}
