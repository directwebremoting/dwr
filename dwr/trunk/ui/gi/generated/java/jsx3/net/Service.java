/*
 * Copyright 2005 Joe Walker
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jsx3.net;

import org.directwebremoting.ScriptBuffer;
import org.directwebremoting.ScriptSessions;
import org.directwebremoting.io.Context;

/**
 * This class is used in conjunction with the XML Mapping Utility to provide transactional support for those services using XML-based messaging.
Support includes those services defined via Schema, XML, XHTML, and WSDL (SOAP).  In practice a developer would open General Interfaceª Builder
to access the XML Mapping Utility.  They would then point the utility at a "pattern master" (i.e., WSDL, Schema, XML, etc) and begin using its
visual tools to bind application objects to nodes in the XML messages to be sent and received.
The output from the Mapping Utility is referred to as a mapping rule set.  This rule set is an XML document based upon the Common Exchange Format (CXF)
and defines the information necessary to support transactional data mapping. Many of the APIs available to the Service class allow the devloper to
dynamically update various static values that were set using the XML Mapping Utility.
 * @author Joe Walker [joe at getahead dot org]
 * @author DRAPGEN - Dwr Reverse Ajax Proxy GENerator
 */
public class Service extends jsx3.lang.Object
{
    /**
     * All reverse ajax proxies need context to work from
     * @param context The script that got us to where we are now
     */
    public Service(Context context, String extension)
    {
        super(context, extension);
    }

    /**
     * instance initializer
     * @param strRulesURL The resolved URI for the rules document (a CXF document).
Note: since this class is lazily loaded as of v3.2, the preferred method of instantiating this class is by calling the <code>loadResource</code>
method on the context server (<code>jsx3.app.Server</code>) instance. This ensures proper URL resolution while also establishing the
appropriate server context.
     * @param strOperationName name of operation to call. This is only required if the rules file was generated via a WSDL.
     * @param strOutboundURL address of a sample outbound message to use as opposed to the one generated by the tool
     * @param strInboundURL when the project is run in static mode (as defined by the 'project deployment options' dialog),
this document is used to simulate a typical server response
     */
    public Service(String strRulesURL, String strOperationName, String strOutboundURL, String strInboundURL)
    {
        super((Context) null, (String) null);
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall("new Service", strRulesURL, strOperationName, strOutboundURL, strInboundURL);
        setInitScript(script);
    }


    /**
     * event type for successful response
     */
    public static final String ON_SUCCESS = "onSuccess";

    /**
     * event type for unsuccessful response
     */
    public static final String ON_ERROR = "onError";

    /**
     * Event type published when the response is still not ready after the specified timeout period.
     */
    public static final String ON_TIMEOUT = "onTimeout";

    /**
     * Event type published each time a rule with one or more restrictions fails during message generation. The following named properties are available on the event object:


          rule the rule node

          message the message node

          target this jsx3.net.Service instance

          type the type of restriction that caused the invalidation event to be publsihed. For example, pattern.

          value the value for the type. For example if type is pattern, then [A-Z]*
     */
    public static final String ON_INVALID = "onInvalid";

    /**
     * Event type published each time a mapping rule is used to create a node, locate a node, or map to a node.


          target this jsx3.net.Service instance

          rule the rule node being processed

          action the action being performed by the rule. For example, Create Node, Map to Cache, Invalidate Node, etc.

          description a description of the 'action'. For example, this.eval(setValue(2));


          level the log level (e.g., 'severity' level) for the message. For example, 6 would signify a 'Trace' level event.
     */
    public static final String ON_PROCESS_RULE = "onProcessRule";


    /**
     * Returns a CR-LF delimited list of supported namespaces and thei related prefix (as defined by the Object, jsx3.net.Service.ns). Any nodes in a rules document (CXF) that implements one of the namespaces listed by this function, should implement the corresponding namespace prefix as also detailed here.
     */

    public void getSupportedNamespaces(org.directwebremoting.ui.Callback<String> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "getSupportedNamespaces");

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, String.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Gets the URL for the rules file to use (a CXF document). This rules file will be used by the Service instance to generate, send, receive and process XML messages
     */

    public void getRulesURL(org.directwebremoting.ui.Callback<String> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "getRulesURL");

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, String.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Sets the URL for the rules file to use (a CXF document). This rules file will be used by the Service instance to generate, send, receive and process XML messages
     * @param strRulesURL
     * @return reference to self
     */
    public jsx3.net.Service setRulesURL(String strRulesURL)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setRulesURL", strRulesURL);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Sets the document that will serve as the container for the message generated by doCall and/or getServiceMessage.
This is a useful way to dynamically assemble documents by chaining multiple service instances, using the output from one service as the input to another.
For example, when a SOAP Envelope requires both a SOAP Header as well as a SOAP Body, this method allows the Envelope to be assembled via a
two-step process of first adding mapped content to the Body, followed by a call to add mapped content to the Header.
Note that this method takes precedence over the static stub document url referenced in the rules file as well as
any call to setOutboundStubURL. Use this method in conjunction with setOutboundStubPath to
point to the specific location in the document where the generated message should be appended.
     * @param objDocument
     * @return reference to self
     */
    public jsx3.net.Service setOutboundStubDocument(jsx3.xml.CdfDocument objDocument)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setOutboundStubDocument", objDocument);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Gets URL for the base stub to use for the request message (the XML document to contain the generated document)
     */

    public void getOutboundStubURL(org.directwebremoting.ui.Callback<String> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "getOutboundStubURL");

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, String.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Sets the URL to the document that will serve as the container for the message generated by doCall and/or getServiceMessage.
Overrides the static setting stored in the rules file. Use this method in conjunction with setOutboundStubPath to
point to the specific location in the document where the generated message should be appended.
     * @param strURL URL for the document. Note that this URL will be resolved relative to the context server.
For example, if the project directory for the context server is 'test', then the following inputs (all of which are valid) are
equivalent: <code>jsxapp://test/xml/typical.xml</code>, <b>and</b> <code>xml/typical.xml</code>, <b>and</b> <code>JSXAPPS/test/xml/typical.xml</code>
     * @return reference to self
     */
    public jsx3.net.Service setOutboundStubURL(String strURL)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setOutboundStubURL", strURL);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Gets the namespace for the server/project to run the service instance within. If a namespace isn't provided, the system will look for the first
application and use its namespace. If no applications exist, the namespace will be completely ignored.
     */

    public void getNamespace(org.directwebremoting.ui.Callback<String> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "getNamespace");

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, String.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Returns the server that this service runs in, as set by the setNamespace() method.
     */

    public jsx3.app.Server getServer()
    {
        String extension = "getServer().";
        try
        {
            java.lang.reflect.Constructor<jsx3.app.Server> ctor = jsx3.app.Server.class.getConstructor(Context.class, String.class);
            return ctor.newInstance(this, extension);
        }
        catch (Exception ex)
        {
            throw new IllegalArgumentException("Unsupported type: " + jsx3.app.Server.class.getName());
        }
    }


    /**
     * Sets the namespace for the server/project to run the service instance within.
     * @param namespace the server (preferred) or the namespace of the server.
     * @return this object
     */
    public jsx3.net.Service setNamespace(jsx3.app.Server namespace)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setNamespace", namespace);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Sets the namespace for the server/project to run the service instance within.
     * @param namespace the server (preferred) or the namespace of the server.
     * @return this object
     */
    public jsx3.net.Service setNamespace(String namespace)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setNamespace", namespace);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Gets XPath address for the node in the outbound stub document to which to append the generated message.
     * @param callback Valid XSL path
     */

    public void getOutboundStubPath(org.directwebremoting.ui.Callback<String> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "getOutboundStubPath");

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, String.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Sets XPath address for the node in the outbound stub document to which to append the generated message.
Overrides the static setting in the rules file.
     * @param strPath Valid XSL path. For example, <code>/SOAP-ENV:Envelope/SOAP-ENV:Body</code>
     * @return reference to self
     */
    public jsx3.net.Service setOutboundStubPath(String strPath)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setOutboundStubPath", strPath);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Gets the URL for a "typical", XML-formatted server resonse document. This document is then used when the project is
run in static mode (as defined by the Project Deployment Options).
     */

    public void getInboundURL(org.directwebremoting.ui.Callback<String> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "getInboundURL");

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, String.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Sets the URL for a "typical", XML-formatted server resonse document. This document is then used when the project is
run in static mode (as defined by the Project Settings dialog). Overrides the static setting in the rules file.
     * @param strInboundURL Alternate URL for the "typical" Service response. Note that this URL will be resolved
relative to the context server. For example, if the project directory for the context server is 'test',
then the following inputs (all of which are valid) are equivalent: <code>jsxapp://test/xml/typical.xml</code>,
<b>and</b> <code>xml/typical.xml</code>, <b>and</b> <code>JSXAPPS/test/xml/typical.xml</code>
     * @return reference to self
     */
    public jsx3.net.Service setInboundURL(String strInboundURL)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setInboundURL", strInboundURL);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Gets URL for a 'typical' XML-formatted request document to send to the server; when this is set, the mapper does not even attempt to generate a document. Instead, this document is sent directly to the server without any processing. Useful for testing requests that never change
     */

    public void getOutboundURL(org.directwebremoting.ui.Callback<String> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "getOutboundURL");

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, String.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Sets the URL for a static XML-formatted request document to send to the Service. Note that when this is set, the mapper does not even
attempt to generate a request document via the rules file. Instead, the static request document is sent directly to the remote Service
without any processing. This is useful for requests that never change or as a means to test whether a Service is working, using a known, valid input.
     * @param strOutboundURL Alternate URL for the static request to send. Note that this URL will be resolved relative
to the context server. For example, if the project directory for the context server is 'test', then the following inputs
(all of which are valid) are equivalent:  <code>jsxapp://test/xml/typical.xml</code>, <b>and</b> <code>xml/typical.xml</code>,
<b>and</b> <code>JSXAPPS/test/xml/typical.xml</code>
     * @return reference to self
     */
    public jsx3.net.Service setOutboundURL(String strOutboundURL)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setOutboundURL", strOutboundURL);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Gets the name of the operation to use within a multi-operation rules file. Note: Rules created via a WSDL often have multiple named operations. Rules files generated without a WSDL contain no named operations, and instead use a single transaction.
     */

    public void getOperationName(org.directwebremoting.ui.Callback<String> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "getOperationName");

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, String.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Sets the name of the operation to use within a multi-operation rules file. Note: Rules created via a WSDL often have multiple operations
     * @param strOperationName operation name
     * @return reference to self
     */
    public jsx3.net.Service setOperationName(String strOperationName)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setOperationName", strOperationName);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Returns the rules document used by the Service instance (a CXF document)
     */

    public jsx3.xml.CdfDocument getRulesXML()
    {
        String extension = "getRulesXML().";
        try
        {
            java.lang.reflect.Constructor<jsx3.xml.CdfDocument> ctor = jsx3.xml.CdfDocument.class.getConstructor(Context.class, String.class);
            return ctor.newInstance(this, extension);
        }
        catch (Exception ex)
        {
            throw new IllegalArgumentException("Unsupported type: " + jsx3.xml.CdfDocument.class.getName());
        }
    }

    /**
     * Returns the rules document used by the Service instance (a CXF document)
     * @param returnType The expected return type
     */

    public <T> T getRulesXML(Class<T> returnType)
    {
        String extension = "getRulesXML().";
        try
        {
            java.lang.reflect.Constructor<T> ctor = returnType.getConstructor(Context.class, String.class);
            return ctor.newInstance(this, extension);
        }
        catch (Exception ex)
        {
            throw new IllegalArgumentException("Unsupported return type: " + returnType.getName());
        }
    }

    /**
     * Dereferences the parsed rules tree (a jsx3.xml.Document instance) managed by this Service instance, forcing a reload of the document from disk the next time the rules document is requested
     * @return reference to self
     */

    public jsx3.net.Service resetRulesTree()
    {
        String extension = "resetRulesTree().";
        try
        {
            java.lang.reflect.Constructor<jsx3.net.Service> ctor = jsx3.net.Service.class.getConstructor(Context.class, String.class);
            return ctor.newInstance(this, extension);
        }
        catch (Exception ex)
        {
            throw new IllegalArgumentException("Unsupported type: " + jsx3.net.Service.class.getName());
        }
    }


    /**
     * Gets user name to send as part of the http request (for servers requiring http authentication)
     */

    public void getUserName(org.directwebremoting.ui.Callback<String> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "getUserName");

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, String.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Sets the user name to send with the posting (for those sites requiring http authentication)
     * @param strName user name
     * @return reference to self
     */
    public jsx3.net.Service setUserName(String strName)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setUserName", strName);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Gets password to send as part of the http request (for servers requiring http authentication)
     */

    public void getUserPass(org.directwebremoting.ui.Callback<String> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "getUserPass");

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, String.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Sets the password to send with the posting (for those sites requiring http authentication)
     * @param strPass password for user
     * @return reference to self
     */
    public jsx3.net.Service setUserPass(String strPass)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setUserPass", strPass);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Gets the jsx3.net.HttpRequest instance that performs the transaction with the remote service (the transport object for the message).
     */

    public jsx3.net.Request getRequest()
    {
        String extension = "getRequest().";
        try
        {
            java.lang.reflect.Constructor<jsx3.net.Request> ctor = jsx3.net.Request.class.getConstructor(Context.class, String.class);
            return ctor.newInstance(this, extension);
        }
        catch (Exception ex)
        {
            throw new IllegalArgumentException("Unsupported type: " + jsx3.net.Request.class.getName());
        }
    }


    /**
     * Call this method after the service has responded to get a parsed instance of the server's XML response
     */

    public jsx3.xml.CdfDocument getInboundDocument()
    {
        String extension = "getInboundDocument().";
        try
        {
            java.lang.reflect.Constructor<jsx3.xml.CdfDocument> ctor = jsx3.xml.CdfDocument.class.getConstructor(Context.class, String.class);
            return ctor.newInstance(this, extension);
        }
        catch (Exception ex)
        {
            throw new IllegalArgumentException("Unsupported type: " + jsx3.xml.CdfDocument.class.getName());
        }
    }

    /**
     * Call this method after the service has responded to get a parsed instance of the server's XML response
     * @param returnType The expected return type
     */

    public <T> T getInboundDocument(Class<T> returnType)
    {
        String extension = "getInboundDocument().";
        try
        {
            java.lang.reflect.Constructor<T> ctor = returnType.getConstructor(Context.class, String.class);
            return ctor.newInstance(this, extension);
        }
        catch (Exception ex)
        {
            throw new IllegalArgumentException("Unsupported return type: " + returnType.getName());
        }
    }

    /**
     * Sets a parsed instance of the response document as soon as it returns from the server returned from the service; otherwise null
     * @param objXML
     */
    public void setInboundDocument(jsx3.xml.CdfDocument objXML)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setInboundDocument", objXML);
        ScriptSessions.addScript(script);
    }

    /**
     * Call this method after 'doCall' has been called to get a parsed instance of the request document--what was actually sent to the remote service
     */

    public jsx3.xml.CdfDocument getOutboundDocument()
    {
        String extension = "getOutboundDocument().";
        try
        {
            java.lang.reflect.Constructor<jsx3.xml.CdfDocument> ctor = jsx3.xml.CdfDocument.class.getConstructor(Context.class, String.class);
            return ctor.newInstance(this, extension);
        }
        catch (Exception ex)
        {
            throw new IllegalArgumentException("Unsupported type: " + jsx3.xml.CdfDocument.class.getName());
        }
    }

    /**
     * Call this method after 'doCall' has been called to get a parsed instance of the request document--what was actually sent to the remote service
     * @param returnType The expected return type
     */

    public <T> T getOutboundDocument(Class<T> returnType)
    {
        String extension = "getOutboundDocument().";
        try
        {
            java.lang.reflect.Constructor<T> ctor = returnType.getConstructor(Context.class, String.class);
            return ctor.newInstance(this, extension);
        }
        catch (Exception ex)
        {
            throw new IllegalArgumentException("Unsupported return type: " + returnType.getName());
        }
    }

    /**
     * Gets the URL for the service endpoint where the request will be sent
     */

    public void getEndpointURL(org.directwebremoting.ui.Callback<String> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "getEndpointURL");

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, String.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Sets the URL for the service endpoint where the request will be sent. Overrides the endpoint specified in the rules file.
     * @param strAlternateURL
     * @return reference to self
     */
    public jsx3.net.Service setEndpointURL(String strAlternateURL)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setEndpointURL", strAlternateURL);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Gets the method for the request. Default is POST
     * @param callback one of: GET or POST
     */

    public void getMethod(org.directwebremoting.ui.Callback<String> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "getMethod");

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, String.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Sets the method for the request different than the one described in the rules file.
     * @param METHOD one of: GET or POST
     */
    public void setMethod(String METHOD)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setMethod", METHOD);
        ScriptSessions.addScript(script);
    }

    /**
     * Generates the request message (if applicable) and sends to the remote service.
     * @param bCancelIfInvalid If true, the remote service will not be called if the message does not pass validation while being generated.
     * @param callback true if the message passed all validation rules while being generated.
     */

    public void doCall(boolean bCancelIfInvalid, org.directwebremoting.ui.Callback<Boolean> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "doCall", bCancelIfInvalid);

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, Boolean.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Sets an HTTP Request header on the request. Set before calling, doCall()
     * @param strName name for header parameter
     * @param strValue value for the header parameter
     */
    public void setRequestHeader(String strName, String strValue)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setRequestHeader", strName, strValue);
        ScriptSessions.addScript(script);
    }

    /**
     * Specifies how long to wait for the service to respond before cancelling the call. Subscribes to the ON_TIMEOUT event
     * @param intTimeout number of milliseconds to wait befor publishing the ON_TIMEOUT event.
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     * @return reference to self
     */
    public jsx3.net.Service setTimeout(int intTimeout, jsx3.lang.Object objHandler, String objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setTimeout", intTimeout, objHandler, objFunction);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Specifies how long to wait for the service to respond before cancelling the call. Subscribes to the ON_TIMEOUT event
     * @param intTimeout number of milliseconds to wait befor publishing the ON_TIMEOUT event.
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     * @return reference to self
     */
    public jsx3.net.Service setTimeout(int intTimeout, org.directwebremoting.ui.CodeBlock objHandler, org.directwebremoting.ui.CodeBlock objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setTimeout", intTimeout, objHandler, objFunction);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Specifies how long to wait for the service to respond before cancelling the call. Subscribes to the ON_TIMEOUT event
     * @param intTimeout number of milliseconds to wait befor publishing the ON_TIMEOUT event.
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     * @return reference to self
     */
    public jsx3.net.Service setTimeout(int intTimeout, String objHandler, org.directwebremoting.ui.CodeBlock objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setTimeout", intTimeout, objHandler, objFunction);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Specifies how long to wait for the service to respond before cancelling the call. Subscribes to the ON_TIMEOUT event
     * @param intTimeout number of milliseconds to wait befor publishing the ON_TIMEOUT event.
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     * @return reference to self
     */
    public jsx3.net.Service setTimeout(int intTimeout, org.directwebremoting.ui.CodeBlock objHandler, String objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setTimeout", intTimeout, objHandler, objFunction);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Specifies how long to wait for the service to respond before cancelling the call. Subscribes to the ON_TIMEOUT event
     * @param intTimeout number of milliseconds to wait befor publishing the ON_TIMEOUT event.
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     * @return reference to self
     */
    public jsx3.net.Service setTimeout(int intTimeout, jsx3.lang.Object objHandler, org.directwebremoting.ui.CodeBlock objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setTimeout", intTimeout, objHandler, objFunction);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Specifies how long to wait for the service to respond before cancelling the call. Subscribes to the ON_TIMEOUT event
     * @param intTimeout number of milliseconds to wait befor publishing the ON_TIMEOUT event.
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     * @return reference to self
     */
    public jsx3.net.Service setTimeout(int intTimeout, String objHandler, String objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setTimeout", intTimeout, objHandler, objFunction);
        ScriptSessions.addScript(script);
        return this;
    }

    /**
     * Resets the rules tree to default state (with all 'skip' flags removed) from those rules that were skipped during the previous transaction
     * @return reference to self
     */

    public jsx3.net.Service resetRules()
    {
        String extension = "resetRules().";
        try
        {
            java.lang.reflect.Constructor<jsx3.net.Service> ctor = jsx3.net.Service.class.getConstructor(Context.class, String.class);
            return ctor.newInstance(this, extension);
        }
        catch (Exception ex)
        {
            throw new IllegalArgumentException("Unsupported type: " + jsx3.net.Service.class.getName());
        }
    }


    /**
     * Gets the request message specific to the MESSAGETYPE (input, output, fault). Typically only used for input (outbound) messages, but can be used for simulating a server response for output and fault (in the case of a SOAP transaction, fault) messages
     * @param MESSAGETYPE one of: input, output, or fault. If this value is provided, the server will generate test data for all nodes lacking a mapped or scripted value
     * @param strShellURL relative URL to message shell to use as the starting container to put content into. Note that calling <code>setOutboundStubURL</code> or <code>setOutboundStubDocument</code> in conjunction with <code>setOutboundStubPath</code>
are preferred to passing this parameter, since they provide much greater control. Also note that this value is stored statically in the rules document when the rules document is first created via the XML Mapping Utility.
     */

    public jsx3.xml.CdfDocument getServiceMessage(String MESSAGETYPE, String strShellURL)
    {
        String extension = "getServiceMessage(\"" + MESSAGETYPE + "\", \"" + strShellURL + "\").";
        try
        {
            java.lang.reflect.Constructor<jsx3.xml.CdfDocument> ctor = jsx3.xml.CdfDocument.class.getConstructor(Context.class, String.class);
            return ctor.newInstance(this, extension);
        }
        catch (Exception ex)
        {
            throw new IllegalArgumentException("Unsupported type: " + jsx3.xml.CdfDocument.class.getName());
        }
    }

    /**
     * Gets the request message specific to the MESSAGETYPE (input, output, fault). Typically only used for input (outbound) messages, but can be used for simulating a server response for output and fault (in the case of a SOAP transaction, fault) messages
     * @param MESSAGETYPE one of: input, output, or fault. If this value is provided, the server will generate test data for all nodes lacking a mapped or scripted value
     * @param strShellURL relative URL to message shell to use as the starting container to put content into. Note that calling <code>setOutboundStubURL</code> or <code>setOutboundStubDocument</code> in conjunction with <code>setOutboundStubPath</code>
are preferred to passing this parameter, since they provide much greater control. Also note that this value is stored statically in the rules document when the rules document is first created via the XML Mapping Utility.
     * @param returnType The expected return type
     */

    public <T> T getServiceMessage(String MESSAGETYPE, String strShellURL, Class<T> returnType)
    {
        String extension = "getServiceMessage(\"" + MESSAGETYPE + "\", \"" + strShellURL + "\").";
        try
        {
            java.lang.reflect.Constructor<T> ctor = returnType.getConstructor(Context.class, String.class);
            return ctor.newInstance(this, extension);
        }
        catch (Exception ex)
        {
            throw new IllegalArgumentException("Unsupported return type: " + returnType.getName());
        }
    }

    /**
     * Gets the HTTP response code (i.e., 200, 404, 500, etc). This will be the response code provided by the bound jsx3.net.Request instance
used for the transport. However, if setStatus has been called on the Service instance, the value supplied by the developer will be used instead.
     */

    public void getStatus(org.directwebremoting.ui.Callback<Integer> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "getStatus");

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, Integer.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Sets the HTTP response code (i.e., 200, 404, 500, etc). Typically, the Service instance determines this value by querying the bound request instance
(jsx3.net.Request) returned by the method, [service_instance].getRequest(). However, calling this method will override
normal operation by forcing a valid/invalid state that affects methdods relying on the HTTP status
such as doInboundMap.  This is particularly useful for SOAP services that provide alternate processing
instructions and mappings when a Fault occurs as well as when running tests in Static mode.
     * @param intStatus
     */
    public void setStatus(int intStatus)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setStatus", intStatus);
        ScriptSessions.addScript(script);
    }

    /**
     * Gets the mode (static jsx3.Boolean.FALSE or live jsx3.Boolean.TRUE).
     */

    public void getMode(org.directwebremoting.ui.Callback<Boolean> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "getMode");

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, Boolean.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Sets the mode (static jsx3.Boolean.FALSE or live jsx3.Boolean.TRUE).  Overrides the default setting for the context Server
instance within which this Service instnace is running.  (NOTE: This setting is accessible at the server level via the Project Settings dialog.)
Setting this value to jsx3.Boolean.FALSE, forces a test document
to be used to simulate a "typical" server response, instead of actually sending a request to a remote service.  This is useful when setting up
test environments as well as providing "live" interactions when the remote server may not be available.
     * @param MODE
     */
    public void setMode(Boolean MODE)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "setMode", MODE);
        ScriptSessions.addScript(script);
    }

    /**
     * Applies all inbound mappings, using the server response document as the source for the operation. Although this method is called once automatically, it can be called at any time to reapply the mapping rules.
Example usage:
var oService = new jsx3.net.Service();
oService.setInboundDocument(objSomeDocumentIManuallyWantToLoad);
oService.doInboundMap();
     */
    public void doInboundMap()
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "doInboundMap");
        ScriptSessions.addScript(script);
    }

    /**
     * Compiles the CXF rules for this service instance to an equivalent XSLT document. This enables
much faster performance than using the DOM-based iterator (default) to convert the XML response
document into a CDF Document type. Note that this process only supports the map types
CDF Document, CDF Record, and CDF Attribute. Only one CDF Document
can be declared per Operation. Otherwise the compilation will fail.
All other mapping types will be ignored and will not be converted into an XSLT equivalent.  Also note
that the order of a set of sibling mapping rules does not proscribe proper processing by way of
sequence.  This means that any order of sibling mapping rules will result in appropriate processing, regardless of the
sibling node order returned from the given service.  This facilitates nested record structures in that
attributes can first be applied to a given record before child elements (e.g., a 'record') are added.
Stated otherwise, any rule that has a descendant rule that would created a nested 'record' node should follow
all sibling mapping rules that would create an 'attribute' entity. Call this method immediately before/after doCall
for best performance.
     * @return XSLT document
     */

    public jsx3.xml.CdfDocument compile()
    {
        String extension = "compile().";
        try
        {
            java.lang.reflect.Constructor<jsx3.xml.CdfDocument> ctor = jsx3.xml.CdfDocument.class.getConstructor(Context.class, String.class);
            return ctor.newInstance(this, extension);
        }
        catch (Exception ex)
        {
            throw new IllegalArgumentException("Unsupported type: " + jsx3.xml.CdfDocument.class.getName());
        }
    }

    /**
     * Compiles the CXF rules for this service instance to an equivalent XSLT document. This enables
much faster performance than using the DOM-based iterator (default) to convert the XML response
document into a CDF Document type. Note that this process only supports the map types
CDF Document, CDF Record, and CDF Attribute. Only one CDF Document
can be declared per Operation. Otherwise the compilation will fail.
All other mapping types will be ignored and will not be converted into an XSLT equivalent.  Also note
that the order of a set of sibling mapping rules does not proscribe proper processing by way of
sequence.  This means that any order of sibling mapping rules will result in appropriate processing, regardless of the
sibling node order returned from the given service.  This facilitates nested record structures in that
attributes can first be applied to a given record before child elements (e.g., a 'record') are added.
Stated otherwise, any rule that has a descendant rule that would created a nested 'record' node should follow
all sibling mapping rules that would create an 'attribute' entity. Call this method immediately before/after doCall
for best performance.
     * @param returnType The expected return type
     * @return XSLT document
     */

    public <T> T compile(Class<T> returnType)
    {
        String extension = "compile().";
        try
        {
            java.lang.reflect.Constructor<T> ctor = returnType.getConstructor(Context.class, String.class);
            return ctor.newInstance(this, extension);
        }
        catch (Exception ex)
        {
            throw new IllegalArgumentException("Unsupported return type: " + returnType.getName());
        }
    }

    /**
     * Publishes an event to all subscribed objects.
     * @param objEvent the event, should have at least a field 'subject' that is the event id, another common field is 'target' (target will default to this instance)
     * @param callback the number of listeners to which the event was broadcast
     */

    public void publish(jsx3.lang.Object objEvent, org.directwebremoting.ui.Callback<Integer> callback)
    {
        ScriptBuffer script = new ScriptBuffer();
        String callbackPrefix = "";

        if (callback != null)
        {
            callbackPrefix = "var reply = ";
        }

        script.appendCall(callbackPrefix + getContextPath() + "publish", objEvent);

        if (callback != null)
        {
            String key = org.directwebremoting.extend.CallbackHelperFactory.get().saveCallback(callback, Integer.class);
            script.appendCall("__System.activateCallback", key, "reply");
        }

        ScriptSessions.addScript(script);
    }

    /**
     * Subscribes an object or function to a type of event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     */
    public void subscribe(Object[] strEventId, jsx3.lang.Object objHandler, org.directwebremoting.ui.CodeBlock objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "subscribe", strEventId, objHandler, objFunction);
        ScriptSessions.addScript(script);
    }

    /**
     * Subscribes an object or function to a type of event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     */
    public void subscribe(String strEventId, String objHandler, String objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "subscribe", strEventId, objHandler, objFunction);
        ScriptSessions.addScript(script);
    }

    /**
     * Subscribes an object or function to a type of event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     */
    public void subscribe(String strEventId, String objHandler, org.directwebremoting.ui.CodeBlock objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "subscribe", strEventId, objHandler, objFunction);
        ScriptSessions.addScript(script);
    }

    /**
     * Subscribes an object or function to a type of event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     */
    public void subscribe(Object[] strEventId, String objHandler, String objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "subscribe", strEventId, objHandler, objFunction);
        ScriptSessions.addScript(script);
    }

    /**
     * Subscribes an object or function to a type of event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     */
    public void subscribe(Object[] strEventId, jsx3.lang.Object objHandler, String objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "subscribe", strEventId, objHandler, objFunction);
        ScriptSessions.addScript(script);
    }

    /**
     * Subscribes an object or function to a type of event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     */
    public void subscribe(Object[] strEventId, org.directwebremoting.ui.CodeBlock objHandler, org.directwebremoting.ui.CodeBlock objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "subscribe", strEventId, objHandler, objFunction);
        ScriptSessions.addScript(script);
    }

    /**
     * Subscribes an object or function to a type of event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     */
    public void subscribe(String strEventId, jsx3.lang.Object objHandler, String objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "subscribe", strEventId, objHandler, objFunction);
        ScriptSessions.addScript(script);
    }

    /**
     * Subscribes an object or function to a type of event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     */
    public void subscribe(Object[] strEventId, org.directwebremoting.ui.CodeBlock objHandler, String objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "subscribe", strEventId, objHandler, objFunction);
        ScriptSessions.addScript(script);
    }

    /**
     * Subscribes an object or function to a type of event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     */
    public void subscribe(Object[] strEventId, String objHandler, org.directwebremoting.ui.CodeBlock objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "subscribe", strEventId, objHandler, objFunction);
        ScriptSessions.addScript(script);
    }

    /**
     * Subscribes an object or function to a type of event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     */
    public void subscribe(String strEventId, jsx3.lang.Object objHandler, org.directwebremoting.ui.CodeBlock objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "subscribe", strEventId, objHandler, objFunction);
        ScriptSessions.addScript(script);
    }

    /**
     * Subscribes an object or function to a type of event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     */
    public void subscribe(String strEventId, org.directwebremoting.ui.CodeBlock objHandler, String objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "subscribe", strEventId, objHandler, objFunction);
        ScriptSessions.addScript(script);
    }

    /**
     * Subscribes an object or function to a type of event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler if an object, the instance to notify of events (objFunction is required); if a string, the JSX id of the instance to notify of events (objFunction is required), must exist in the same Server; if a function, the function to call to notify of events (objFunction ignored)
     * @param objFunction if objHandler is a string or object then the function to call on that instance. either a function or a string that is the name of a method of the instance
     */
    public void subscribe(String strEventId, org.directwebremoting.ui.CodeBlock objHandler, org.directwebremoting.ui.CodeBlock objFunction)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "subscribe", strEventId, objHandler, objFunction);
        ScriptSessions.addScript(script);
    }

    /**
     * Unsubscribe an object or function from an event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler the value of objHandler passed to subscribe
     */
    public void unsubscribe(String strEventId, jsx3.lang.Object objHandler)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "unsubscribe", strEventId, objHandler);
        ScriptSessions.addScript(script);
    }

    /**
     * Unsubscribe an object or function from an event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler the value of objHandler passed to subscribe
     */
    public void unsubscribe(Object[] strEventId, jsx3.lang.Object objHandler)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "unsubscribe", strEventId, objHandler);
        ScriptSessions.addScript(script);
    }

    /**
     * Unsubscribe an object or function from an event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler the value of objHandler passed to subscribe
     */
    public void unsubscribe(String strEventId, org.directwebremoting.ui.CodeBlock objHandler)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "unsubscribe", strEventId, objHandler);
        ScriptSessions.addScript(script);
    }

    /**
     * Unsubscribe an object or function from an event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler the value of objHandler passed to subscribe
     */
    public void unsubscribe(String strEventId, String objHandler)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "unsubscribe", strEventId, objHandler);
        ScriptSessions.addScript(script);
    }

    /**
     * Unsubscribe an object or function from an event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler the value of objHandler passed to subscribe
     */
    public void unsubscribe(Object[] strEventId, String objHandler)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "unsubscribe", strEventId, objHandler);
        ScriptSessions.addScript(script);
    }

    /**
     * Unsubscribe an object or function from an event published by this object.

As of version 3.4 a string value for objHandler is deprecated.
     * @param strEventId the event type(s).
     * @param objHandler the value of objHandler passed to subscribe
     */
    public void unsubscribe(Object[] strEventId, org.directwebremoting.ui.CodeBlock objHandler)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "unsubscribe", strEventId, objHandler);
        ScriptSessions.addScript(script);
    }

    /**
     * Unsubscribes all subscribed objects to a type of event published by this object.
     * @param strEventId the event type
     */
    public void unsubscribeAll(String strEventId)
    {
        ScriptBuffer script = new ScriptBuffer();
        script.appendCall(getContextPath() + "unsubscribeAll", strEventId);
        ScriptSessions.addScript(script);
    }

}

