/* Generated By:JavaCC: Do not edit this line. JavaccJsonParser.java */
/*
 * Copyright 2005 Joe Walker
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.directwebremoting.json.parse.javacc;

import java.io.Reader;
import java.io.StringReader;
import java.math.BigDecimal;

import org.directwebremoting.json.parse.JsonDecoder;
import org.directwebremoting.json.parse.JsonParseException;
import org.directwebremoting.json.parse.JsonParser;

/**
 * Produced by JavaCC from JavaccJsonParser.jj
 * @author Joe Walker [joe at getahead dot org]
 */
public class JavaccJsonParser implements JsonParser, JavaccJsonParserConstants
{
    /**
     * This constructor does not create a ready-to-roll parser. One of the
     * {@link #ReInit} methods should be called first.
     */
    public JavaccJsonParser()
    {
        this(new StringReader(""));
    }

    /* (non-Javadoc)
     * @see org.directwebremoting.json.parse.JsonParser#parse(java.lang.String, org.directwebremoting.json.parse.JsonDecoder)
     */
    public <T> T parse(Reader reader, JsonDecoder<T> decoder) throws JsonParseException
    {
        ReInit(reader);
        try
        {
            top(decoder);
        }
        catch (TokenMgrError ex)
        {
            throw new JsonParseException(ex.getMessage());
        }
        return decoder.getRoot();
    }

    final public void top(JsonDecoder<?> decoder) throws ParseException
    {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case 12:
            object(decoder);
            break;
        case 19:
            array(decoder);
            break;
        default:
            jj_la1[0] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
    }

    final public void object(JsonDecoder<?> decoder) throws ParseException
    {
        decoder.beginObject();
        jj_consume_token(12);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case QUOTE:
            objectContents(decoder);
            break;
        default:
            jj_la1[1] = jj_gen;
        }
        jj_consume_token(13);
        decoder.endObject();
    }

    final public void objectContents(JsonDecoder<?> decoder) throws ParseException
    {
        pair(decoder);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case 14:
            jj_consume_token(14);
            objectContents(decoder);
            break;
        default:
            jj_la1[2] = jj_gen;
        }
    }

    final public void pair(JsonDecoder<?> decoder) throws ParseException
    {
        string(decoder);
        decoder.beginMember();
        jj_consume_token(15);
        value(decoder);
        decoder.endMember();
    }

    final public void value(JsonDecoder<?> decoder) throws ParseException
    {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case QUOTE:
            string(decoder);
            break;
        case DIGITS:
        case 21:
            number(decoder);
            break;
        case 12:
            object(decoder);
            break;
        case 19:
            array(decoder);
            break;
        case 16:
        case 17:
        case 18:
            literal(decoder);
            break;
        default:
            jj_la1[3] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
    }

    final public void literal(JsonDecoder<?> decoder) throws ParseException
    {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case 16:
            jj_consume_token(16);
            decoder.addBoolean(true);
            break;
        case 17:
            jj_consume_token(17);
            decoder.addBoolean(false);
            break;
        case 18:
            jj_consume_token(18);
            decoder.addNull();
            break;
        default:
            jj_la1[4] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
    }

    final public void array(JsonDecoder<?> decoder) throws ParseException
    {
        decoder.beginArray();
        jj_consume_token(19);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case DIGITS:
        case QUOTE:
        case 12:
        case 16:
        case 17:
        case 18:
        case 19:
        case 21:
            arrayContents(decoder);
            break;
        default:
            jj_la1[5] = jj_gen;
        }
        jj_consume_token(20);
        decoder.endArray();
    }

    final public void arrayContents(JsonDecoder<?> decoder) throws ParseException
    {
        value(decoder);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case 14:
            jj_consume_token(14);
            arrayContents(decoder);
            break;
        default:
            jj_la1[6] = jj_gen;
        }
    }

    final public void number(JsonDecoder<?> decoder) throws ParseException
    {
        String intPart = null;
        String floatPart = null;
        String expPart = null;
        intPart = getIntPart();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case 22:
            floatPart = getFloatPart();
            break;
        default:
            jj_la1[7] = jj_gen;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case E:
            expPart = getExpPart();
            break;
        default:
            jj_la1[8] = jj_gen;
        }
        if (expPart != null)
        {
            decoder.addNumber(new BigDecimal(intPart + floatPart + expPart));
        }
        else if (floatPart != null)
        {
            decoder.addDouble(Double.parseDouble(intPart + floatPart));
        }
        else
        {
            try
            {
                decoder.addInt(Integer.parseInt(intPart));
            }
            catch (NumberFormatException ex)
            {
                try
                {
                    decoder.addLong(Long.parseLong(intPart));
                }
                catch (NumberFormatException ex2)
                {
                    decoder.addNumber(new BigDecimal(intPart));
                }
            }
        }
    }

    final public String getIntPart() throws ParseException
    {
        String digits;
        boolean negative = false;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case 21:
            jj_consume_token(21);
            negative = true;
            break;
        default:
            jj_la1[9] = jj_gen;
        }
        digits = getDigits();
        if (negative)
        {
            {
                if (true)
                {
                    return "-" + digits;
                }
            }
        }
        {
            if (true)
            {
                return digits;
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public String getFloatPart() throws ParseException
    {
        String digits;
        jj_consume_token(22);
        digits = getDigits();
        {
            if (true)
            {
                return "." + digits;
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public String getExpPart() throws ParseException
    {
        Token t;
        String digits;
        t = jj_consume_token(E);
        digits = getDigits();
        {
            if (true)
            {
                return t.image + digits;
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public String getDigits() throws ParseException
    {
        Token t;
        t = jj_consume_token(DIGITS);
        {
            if (true)
            {
                return t.image;
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public void string(JsonDecoder<?> decoder) throws ParseException
    {
        StringBuilder builder = new StringBuilder();
        jj_consume_token(QUOTE);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case CHAR:
        case CNTRL_ESC:
        case HEX_ESC:
            getChars(builder);
            break;
        default:
            jj_la1[10] = jj_gen;
        }
        jj_consume_token(ENDQUOTE);
        decoder.addString(builder.toString());
    }

    final public void getChars(StringBuilder builder) throws ParseException
    {
        char c;
        c = getChar();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case CHAR:
        case CNTRL_ESC:
        case HEX_ESC:
            getChars(builder);
            break;
        default:
            jj_la1[11] = jj_gen;
        }
        builder.insert(0, c);
    }

    final public char getChar() throws ParseException
    {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
        {
        case CHAR:
            t = jj_consume_token(CHAR);
            break;
        case CNTRL_ESC:
            t = jj_consume_token(CNTRL_ESC);
            break;
        case HEX_ESC:
            t = jj_consume_token(HEX_ESC);
            break;
        default:
            jj_la1[12] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        if (t.image.length() < 2)
        {
            {
                if (true)
                {
                    return t.image.charAt(0);
                }
            }
        }
        if (t.image.length() < 6)
        {
            char c = t.image.charAt(1);
            switch (t.image.charAt(1))
            {
            case 'b':
            {
                if (true)
                {
                    return (char) 8;
                }
            }
                break;
            case 'f':
            {
                if (true)
                {
                    return (char) 12;
                }
            }
                break;
            case 'n':
            {
                if (true)
                {
                    return (char) 10;
                }
            }
                break;
            case 'r':
            {
                if (true)
                {
                    return (char) 13;
                }
            }
                break;
            case 't':
            {
                if (true)
                {
                    return (char) 9;
                }
            }
                break;
            default:
            {
                if (true)
                {
                    return c;
                }
            }
            }
        }
        else
        {
            // hex escape code
            int i = Integer.valueOf(t.image.substring(2, 6), 16).intValue();
            {
                if (true)
                {
                    return (char) i;
                }
            }
        }
        throw new Error("Missing return statement in function");
    }

    public JavaccJsonParserTokenManager token_source;

    SimpleCharStream jj_input_stream;

    public Token token, jj_nt;

    private int jj_ntk;

    private int jj_gen;

    final private int[] jj_la1 = new int[13];

    static private int[] jj_la1_0;
    static
    {
        jj_la1_0();
    }

    private static void jj_la1_0()
    {
        jj_la1_0 = new int[] { 0x81000, 0x10, 0x4000, 0x2f1018, 0x70000, 0x2f1018, 0x4000, 0x400000, 0x4, 0x200000, 0x980, 0x980, 0x980, };
    }

    public JavaccJsonParser(java.io.InputStream stream)
    {
        this(stream, null);
    }

    public JavaccJsonParser(java.io.InputStream stream, String encoding)
    {
        try
        {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        }
        catch (java.io.UnsupportedEncodingException e)
        {
            throw new RuntimeException(e);
        }
        token_source = new JavaccJsonParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++)
        {
            jj_la1[i] = -1;
        }
    }

    public void ReInit(java.io.InputStream stream)
    {
        ReInit(stream, null);
    }

    public void ReInit(java.io.InputStream stream, String encoding)
    {
        try
        {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        }
        catch (java.io.UnsupportedEncodingException e)
        {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++)
        {
            jj_la1[i] = -1;
        }
    }

    public JavaccJsonParser(java.io.Reader stream)
    {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new JavaccJsonParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++)
        {
            jj_la1[i] = -1;
        }
    }

    public void ReInit(java.io.Reader stream)
    {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++)
        {
            jj_la1[i] = -1;
        }
    }

    public JavaccJsonParser(JavaccJsonParserTokenManager tm)
    {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++)
        {
            jj_la1[i] = -1;
        }
    }

    public void ReInit(JavaccJsonParserTokenManager tm)
    {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++)
        {
            jj_la1[i] = -1;
        }
    }

    final private Token jj_consume_token(int kind) throws ParseException
    {
        Token oldToken;
        if ((oldToken = token).next != null)
        {
            token = token.next;
        }
        else
        {
            token = token.next = token_source.getNextToken();
        }
        jj_ntk = -1;
        if (token.kind == kind)
        {
            jj_gen++;
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    final public Token getNextToken()
    {
        if (token.next != null)
        {
            token = token.next;
        }
        else
        {
            token = token.next = token_source.getNextToken();
        }
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    final public Token getToken(int index)
    {
        Token t = token;
        for (int i = 0; i < index; i++)
        {
            if (t.next != null)
            {
                t = t.next;
            }
            else
            {
                t = t.next = token_source.getNextToken();
            }
        }
        return t;
    }

    final private int jj_ntk()
    {
        if ((jj_nt = token.next) == null)
        {
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        }
        else
        {
            return (jj_ntk = jj_nt.kind);
        }
    }

    private final java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();

    private int[] jj_expentry;

    private int jj_kind = -1;

    public ParseException generateParseException()
    {
        jj_expentries.removeAllElements();
        boolean[] la1tokens = new boolean[23];
        for (int i = 0; i < 23; i++)
        {
            la1tokens[i] = false;
        }
        if (jj_kind >= 0)
        {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 13; i++)
        {
            if (jj_la1[i] == jj_gen)
            {
                for (int j = 0; j < 32; j++)
                {
                    if ((jj_la1_0[i] & (1 << j)) != 0)
                    {
                        la1tokens[j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 23; i++)
        {
            if (la1tokens[i])
            {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++)
        {
            exptokseq[i] = jj_expentries.elementAt(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    final public void enable_tracing()
    {
    }

    final public void disable_tracing()
    {
    }

}
