<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <title>DWR - Issues</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
  <link rel="stylesheet" type="text/css" href="generic.css"/>
</head>

<body>
<iframe id="sidebar" src="sidebar.html" frameborder="0"></iframe>

<h2>Issues with DWR</h2>

<h3>Security</h3>
<p>
  I'm nervious about the ability DWR might give to an attacker to do things to
  your system that you were not expecting. For that reason I recommend that you
  keep the set of classes that DWR can access fairly separate from the rest of
  the system.
</p>
<p>
  What opportunities does an attacker have to exploit your system? Using DWR
  an attacker can cause the server to create an instance of any Java object that
  you specify in your dwr.xml, and (if you are using the BeanConverter) any Java
  object that is in any of the parameters to the methods to those classes. Any
  of the properties in those classes can then be set with whatever data the
  attacker uses.
</p>
<p>
  This is all a fairly obvious conclusion if you think about what DWR is doing,
  but it could cause problems to the unwary. If you create a FileBean with a
  public appendStringToFile() method and export it using DWR, then you are
  giving an attacker a simple method of filling your filesystem up.
</p>
<p>
  In addition if you didn't specify that object in dwr.xml, but you did specify
  a bean that included FileBean as a parameter, then if you give the attacker
  the same possibilities unless you have your BeanConverter nailed down
  properly.
</p>
<p>
  It is important to think about the options you give attakers as a result of
  using DWR.
</p>

<h3>Asynchronisity</h3>
<p>
  It might be nice if DWR could return the data to Javascript without you
  having to pass a callback function as the first parameter. The bad news is
  that this is unlikely to happen. Javascript is designed to be non-stop, so
  there is no <code>wait()</code> function, you have to set a timeout using
  a function in the same way the DWR uses.
</p>
<p>
  It is possible using the IE HttpXMLRequest object to do a synchronous call.
  However doing so will freeze your browser while the call executes, which if
  the call fails could be very annoying to the user, and in addition the same
  functionallity is not provided by the Mozilla HttpXMLRequest object nor is it
  possible using the iframe method.
</p>
<p>
  It may be more of a hassle writing callback functions but your code will be
  better for it in the long term.
</p>

<h3>Request Ordering</h3>
<p>
  Some applications may require order guarantees to ensure that methods are
  executed on the server in the same order that they are generated in the
  browser, or that replies are received in the same order.
  <br/>
  Neither of these guarantees are easy to fulfill however there are a number of
  options open you you. The simplest would be to call useLoadingMessage() from
  util.js (see the <a href="config-js.html">javascript documentation</a>).
  This ensures that only on event is outstanding at any one time (and gives you
  a gmail type "Loading" message).
  <br/>
  The second option would be to send a browser timestamp with each request and
  have your Java code drop out of date requests. This option is more work
  however is may make your site more responsive. It is worth noting that
  multi-threaded user interfaces have been notoriously tricky to implement so
  this choice may be painful in the future.
  <br/>
  The third option might be to help fix
  <a href="https://dwr.dev.java.net/issues/show_bug.cgi?id=14">bug 14</a> which
  could provide some of these guarantees while requiring the events are sent
  in batch mode. Alternatively
  <a href="https://dwr.dev.java.net/issues/show_bug.cgi?id=18">bug 18</a> sets
  out to fix the root cause of this issue.
</p>

<h3>Marshalling to a collection</h3>
<p>
  Suppose you are trying to call a Java method that does something like this:
</p>
<pre>
public void debugPeople(List people)
{
    for (Iterator it = people.iterator(); it.hasNext();)
    {
        Person person = (Person) it.next();
        System.out.println(person.getDebugInfo());
    }
}
</pre>
<p>
  DWR has a problem: there is nothing in the signature of the method that
  can tell DWR that the List is expected to be a list of people. DWR may well
  have data that it could use to create people, however unless we can tell it
  to create people, we are stuck.
</p>
<p>
  In the short term there are 2 solutions - Either use an array instead of a
  collection, or write the methods to use Collections of Strings. In the long
  term the problem could be solved by everyone changing to the JDK 1.5 syntax.
  There is a potential for us to invent an extension to the dwr.xml config
  file that allowed us to say <code>void debugPeople(List people)</code> is the
  same as <code>void debugPeople(List&lt;Person> people)</code>.
</p>

<h3>JDK 1.3 and Unicode</h3>

<p>
  There is a known issue with the JDK 1.3 version of URLDecoder.decode() not
  being able to handle encodings other than the platform default. So passing
  unicode character to DWR running on JDK 1.3 will not work for the time
  being.
</p>

<h3>Other Issues</h3>

<p>
  This section is being used as a dumping ground for potential gotchas that we
  may get around to investigating one day.
</p>

<p>
  Is there any guarantee that the ordering of param-names as read by DWR will
  be the same as the file ordering? The order in which the files are read is
  important since the files may depend on each other.
</p>

</body>
</html>
